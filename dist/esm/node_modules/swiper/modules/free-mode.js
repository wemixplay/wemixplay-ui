import{d as e,k as t}from"../shared/utils.js";function o(o){let{swiper:s,extendParams:i,emit:n,once:a}=o;i({freeMode:{enabled:!1,momentum:!0,momentumRatio:1,momentumBounce:!0,momentumBounceRatio:1,momentumVelocityRatio:1,sticky:!1,minimumVelocity:.02}}),Object.assign(s,{freeMode:{onTouchStart:function(){if(s.params.cssMode)return;const e=s.getTranslate();s.setTranslate(e),s.setTransition(0),s.touchEventsData.velocities.length=0,s.freeMode.onTouchEnd({currentPos:s.rtl?s.translate:-s.translate})},onTouchMove:function(){if(s.params.cssMode)return;const{touchEventsData:t,touches:o}=s;0===t.velocities.length&&t.velocities.push({position:o[s.isHorizontal()?"startX":"startY"],time:t.touchStartTime}),t.velocities.push({position:o[s.isHorizontal()?"currentX":"currentY"],time:e()})},onTouchEnd:function(o){let{currentPos:i}=o;if(s.params.cssMode)return;const{params:r,wrapperEl:l,rtlTranslate:m,snapGrid:c,touchEventsData:d}=s,u=e()-d.touchStartTime;if(i<-s.minTranslate())s.slideTo(s.activeIndex);else if(i>-s.maxTranslate())s.slides.length<c.length?s.slideTo(c.length-1):s.slideTo(s.slides.length-1);else{if(r.freeMode.momentum){if(d.velocities.length>1){const t=d.velocities.pop(),o=d.velocities.pop(),i=t.position-o.position,n=t.time-o.time;s.velocity=i/n,s.velocity/=2,Math.abs(s.velocity)<r.freeMode.minimumVelocity&&(s.velocity=0),(n>150||e()-t.time>300)&&(s.velocity=0)}else s.velocity=0;s.velocity*=r.freeMode.momentumVelocityRatio,d.velocities.length=0;let o=1e3*r.freeMode.momentumRatio;const i=s.velocity*o;let u=s.translate+i;m&&(u=-u);let f,p=!1;const M=20*Math.abs(s.velocity)*r.freeMode.momentumBounceRatio;let T;if(u<s.maxTranslate())r.freeMode.momentumBounce?(u+s.maxTranslate()<-M&&(u=s.maxTranslate()-M),f=s.maxTranslate(),p=!0,d.allowMomentumBounce=!0):u=s.maxTranslate(),r.loop&&r.centeredSlides&&(T=!0);else if(u>s.minTranslate())r.freeMode.momentumBounce?(u-s.minTranslate()>M&&(u=s.minTranslate()+M),f=s.minTranslate(),p=!0,d.allowMomentumBounce=!0):u=s.minTranslate(),r.loop&&r.centeredSlides&&(T=!0);else if(r.freeMode.sticky){let e;for(let t=0;t<c.length;t+=1)if(c[t]>-u){e=t;break}u=Math.abs(c[e]-u)<Math.abs(c[e-1]-u)||"next"===s.swipeDirection?c[e]:c[e-1],u=-u}if(T&&a("transitionEnd",(()=>{s.loopFix()})),0!==s.velocity){if(o=m?Math.abs((-u-s.translate)/s.velocity):Math.abs((u-s.translate)/s.velocity),r.freeMode.sticky){const e=Math.abs((m?-u:u)-s.translate),t=s.slidesSizesGrid[s.activeIndex];o=e<t?r.speed:e<2*t?1.5*r.speed:2.5*r.speed}}else if(r.freeMode.sticky)return void s.slideToClosest();r.freeMode.momentumBounce&&p?(s.updateProgress(f),s.setTransition(o),s.setTranslate(u),s.transitionStart(!0,s.swipeDirection),s.animating=!0,t(l,(()=>{s&&!s.destroyed&&d.allowMomentumBounce&&(n("momentumBounce"),s.setTransition(r.speed),setTimeout((()=>{s.setTranslate(f),t(l,(()=>{s&&!s.destroyed&&s.transitionEnd()}))}),0))}))):s.velocity?(n("_freeModeNoMomentumRelease"),s.updateProgress(u),s.setTransition(o),s.setTranslate(u),s.transitionStart(!0,s.swipeDirection),s.animating||(s.animating=!0,t(l,(()=>{s&&!s.destroyed&&s.transitionEnd()})))):s.updateProgress(u),s.updateActiveIndex(),s.updateSlidesClasses()}else{if(r.freeMode.sticky)return void s.slideToClosest();r.freeMode&&n("_freeModeNoMomentumRelease")}(!r.freeMode.momentum||u>=r.longSwipesMs)&&(n("_freeModeStaticRelease"),s.updateProgress(),s.updateActiveIndex(),s.updateSlidesClasses())}}}})}export{o as default};
